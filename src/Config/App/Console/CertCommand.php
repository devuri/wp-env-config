<?php

namespace DevUri\Config\App\Console;

use InvalidArgumentException;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Exception\ProcessFailedException;
use Symfony\Component\Process\Process;

class CertCommand extends Command
{
    protected static $defaultName = 'ssl';

    protected function configure(): void
    {
        $this->setDescription( 'Provisions SSL for a domain.' )
            ->addOption( 'domain', null, InputOption::VALUE_REQUIRED, 'Domain name for SSL provisioning' )
            ->addOption( 'email', null, InputOption::VALUE_REQUIRED, 'Email address for SSL notifications' );
    }

    /**
     * SSL certificates by Certbot
     *
     * To automate the renewal of SSL certificates generated by Certbot
     * You can add renewal command to a cron file to run it every day at midnight,
     * for example: `certbot renew` or use supervisor
     *
     * // ssl --domain mydomain.com --email admin@mydomain.com
     *
     * @return int
     *
     * @psalm-return 0|1
     */
    protected function execute( InputInterface $input, OutputInterface $output ): int
    {
        $_domain = $input->getOption( 'domain' );
        $_email  = $input->getOption( 'email' );

        $process = new Process(['which', 'certbot']);
        $process->run();

        if ($process->getExitCode() !== 0) {
            $output->writeln('<error>Certbot is not installed. Please install Certbot and try again.</error>');
            return Command::FAILURE;
        }

		// TODO verify domain.
        // if ( ! is_domain( $_domain ) ) {
        //     throw new InvalidArgumentException( sprintf( 'Invalid domain: %s', $_domain ) );
        // }

        $output->writeln( '<info>SSL certificate...</info>' );

		$cmd = sprintf( '--nginx -d %s --non-interactive --agree-tos --email %s', $_domain, $_email );

        $process = new Process([ 'certbot', 'certonly', $cmd ] );
        $process->setTimeout( null );
        $process->setIdleTimeout( null );

        try {
            $process->start();

            foreach ( $process as $type => $data ) {
                if ( Process::OUT === $type ) {
                    $output->write( $data );
                }
            }

            if ( ! $process->isSuccessful() ) {
                throw new ProcessFailedException( $process );
            }
        } catch ( ProcessFailedException $e ) {
            $output->writeln( sprintf( '<error>The server could not be started: %s</error>', $e->getMessage() ) );

            return Command::FAILURE;
        }

        return Command::SUCCESS;
    }
}
